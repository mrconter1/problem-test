<!DOCTYPE html>
<html>
<head>
    <title>Stair Model Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            font-family: monospace;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-family: Arial, sans-serif;
        }
        #modelSelect {
            margin-top: 5px;
            padding: 5px;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 3px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="info">Loading stair model...</div>
    <div id="controls">
        <label for="modelSelect">Select Stair Model:</label>
        <select id="modelSelect"></select>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, -20, 20);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Add orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        
        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // Add a grid helper aligned with XY plane (where Z is up)
        const gridSize = 100;
        const gridDivisions = 100;
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x888888, 0x444444);
        // Rotate the grid to align with XY plane (where Z is up)
        gridHelper.rotation.x = Math.PI / 2;
        scene.add(gridHelper);
        
        // Add axes helper
        const axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);
        
        // Function to create text sprite for axis labels
        function createTextSprite(text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
            
            context.font = "Bold 60px Arial";
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 128, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(5, 5, 1);
            
            return sprite;
        }
        
        // Add axis labels
        const xLabel = createTextSprite("X", "#ff0000");
        xLabel.position.set(12, 0, 0);
        scene.add(xLabel);
        
        const yLabel = createTextSprite("Y", "#00ff00");
        yLabel.position.set(0, 12, 0);
        scene.add(yLabel);
        
        const zLabel = createTextSprite("Z", "#0000ff");
        zLabel.position.set(0, 0, 12);
        scene.add(zLabel);
        
        // Function to create a rectangle from 4 points
        function createRectangle(points, z, color) {
            const shape = new THREE.Shape();
            shape.moveTo(points[0].x, points[0].y);
            shape.lineTo(points[1].x, points[1].y);
            shape.lineTo(points[2].x, points[2].y);
            shape.lineTo(points[3].x, points[3].y);
            shape.lineTo(points[0].x, points[0].y);
            
            const geometry = new THREE.ShapeGeometry(shape);
            const material = new THREE.MeshLambertMaterial({ 
                color: color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = z;
            
            return mesh;
        }
        
        // Store all stair models
        let allStairModels = [];
        // Group to hold the current model's objects
        const modelGroup = new THREE.Group();
        scene.add(modelGroup);
        
        // Function to visualize a stair model
        function visualizeStairModel(stairModel) {
            // Clear previous model
            while(modelGroup.children.length > 0) { 
                modelGroup.remove(modelGroup.children[0]); 
            }
            
            const infoElement = document.getElementById('info');
            infoElement.textContent = `Stair Model: ${stairModel.name} (ID: ${stairModel.id})`;
            
            // Center the model
            const boundingBox = stairModel.boundingBox;
            const centerX = (boundingBox.min.x + boundingBox.max.x) / 2;
            const centerY = (boundingBox.min.y + boundingBox.max.y) / 2;
            
            // Find horizontal 4-line loops
            let horizontalRectangles = [];
            let colorIndex = 0;
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
            
            stairModel.solids.forEach(solid => {
                solid.faces.forEach(face => {
                    face.loops.forEach(loop => {
                        // Check if it's a 4-line loop
                        if (loop.length === 4) {
                            // Check if all points have the same z-value
                            const referenceZ = loop[0].start.z;
                            let isHorizontal = true;
                            
                            for (const line of loop) {
                                if (line.start.z !== referenceZ || line.end.z !== referenceZ) {
                                    isHorizontal = false;
                                    break;
                                }
                            }
                            
                            if (isHorizontal) {
                                // Extract the points
                                const points = [
                                    { x: loop[0].start.x - centerX, y: loop[0].start.y - centerY },
                                    { x: loop[1].start.x - centerX, y: loop[1].start.y - centerY },
                                    { x: loop[2].start.x - centerX, y: loop[2].start.y - centerY },
                                    { x: loop[3].start.x - centerX, y: loop[3].start.y - centerY }
                                ];
                                
                                // Create a rectangle and add it to the scene
                                const color = colors[colorIndex % colors.length];
                                const rectangle = createRectangle(points, referenceZ, color);
                                modelGroup.add(rectangle);
                                
                                horizontalRectangles.push({
                                    z: referenceZ,
                                    mesh: rectangle
                                });
                                
                                colorIndex++;
                            }
                        }
                    });
                });
            });
            
            // Update info
            infoElement.textContent += `\nFound ${horizontalRectangles.length} horizontal rectangles`;
            
            // Add a legend explaining the coordinate system
            infoElement.textContent += `\n\nCoordinate System:`;
            infoElement.textContent += `\nX-axis (Red): Width`;
            infoElement.textContent += `\nY-axis (Green): Depth`;
            infoElement.textContent += `\nZ-axis (Blue): Height`;
            
            // Adjust camera to see the model
            const bbox = new THREE.Box3().setFromObject(modelGroup);
            const center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            
            // Position camera to see the entire model
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.5; // Add some margin
            
            camera.position.set(center.x, center.y - cameraZ, center.z + cameraZ);
            camera.lookAt(center);
            controls.target.copy(center);
        }
        
        // Load the stair models
        fetch('stair.json')
            .then(response => response.json())
            .then(data => {
                // Handle both single object and array
                allStairModels = Array.isArray(data) ? data : [data];
                
                // Populate the dropdown
                const modelSelect = document.getElementById('modelSelect');
                allStairModels.forEach((model, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${model.name} (ID: ${model.id})`;
                    modelSelect.appendChild(option);
                });
                
                // Add event listener for dropdown changes
                modelSelect.addEventListener('change', function() {
                    const selectedIndex = parseInt(this.value);
                    visualizeStairModel(allStairModels[selectedIndex]);
                });
                
                // Visualize the first model initially
                if (allStairModels.length > 0) {
                    visualizeStairModel(allStairModels[0]);
                }
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                }
                
                animate();
            })
            .catch(error => {
                console.error('Error loading stair model:', error);
                document.getElementById('info').textContent = 'Error loading stair model: ' + error.message;
            });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html> 